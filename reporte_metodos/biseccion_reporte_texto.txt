ALGORITMO DE BISECCION.

Temas por abarcar en la explicación:
-Requerimientos y condiciones
-épsilon como criterio de detención
-Teorema de Bolzano
-Filosofía del algoritmo (encontrar raíce, etc)
-Explicación del algoritmo
-Ejemplo 1. Ecuación sencilla
-Ejemplo 2. Con el problema general
-Análisis de rendimiento (con pros, contras y rendimiento puro)
-Hacer un resumen de todo. Como una ficha del fifa para cada 

REQUERIMIENTOS:
-La función tiene que ser continua en el rango en el cual se va a trabajar.



N. METODO DE BISECCION
El método de bisección es un método numerico diseñado para encontrar raíces de ecuaciones (puntos en los que la función es 0). Como muchos de los algoritmos y métodos del curso, este método esta pensado para encontrar
estos puntos cuando por alguna razón sea mas difícil o imposible encontrar las raíces de forma analítica. La biseccion destaca por lo sencillo del metodo, su velocidad y los pocos requerimientos que tiene.
 
A grandes rasgos este método usa como base el teorema de Bolzano para ir dividiendo iterativamente por la mitad rangos donde se sabe que esta el punto en el que la función vale 0 (f(O) = 0) y el proceso se detiene cuando el rango sea
igual o menor que un valor de referencia establecido previamente. 

----N.1 REQUERIMIENTOS:
Este método requiere:
1. Que la función tenga puntos con signos contrarios
2. Que sea continua por 0 y sus alrededores
3. Como muchos metodos similares, un epsilon de detencion.
4. Solo para funciones en R2
5. Saber en que rango pasa el 0


----N.2. Teorema de Bolzano.

Formalmente el teorema de Bolzano establece lo siguiente:
… (explicación formal con LaTeX, fuentes y todo el rollo)

De otra forma, si una función es continua en un rango [a, b], en el cual la función toma valores con signos contrarios, significa que en ese rango, hay algún punto en el que la función tomara el valor de 0.
Si pasa de ser negativa a positiva, a fuerzas tuvo que pasar por el 0.
Este teorema es la base teorica sobre la cual el método de bisección opera. Por eso se requiere que la función a la cual se le aplique el algoritmo sea continua.

----N.3. Algoritmo de bisección.
(Imagen)

A grandes rasgos, el algoritmo de biseccion consiste en: 
1. Establecer un rango inicial [a, b] en el cual se sabe que existe una raiz y signos contrarios.
Se tiene que establecer un rango por donde se sepa que esta f(x) = 0 y los limites sean de signos contrarios. Si f(a) > 0 => f(b) < 0 y viceversa

2. Establecer un épsilon como criterio de detención.
El 'epsilon' es un valor de referencia que se usara para detener el algoritmo. Cuando la diferencia entre el limite nuevo y el anterior (a - c) sea menor que este epsilon, significaria que el rango ya es lo suficientemente chico que mas 
iteraciones son irrelevantes

3. Calcular el punto medio del rango.
usando el rango ams reciente, el punto se puede calcular con (a+b)/2

3.1. Si el punto medio es mayor que 0, se sustituye ese punto con el limite de signo positivo.
Si la funcion es mayor que 0 en el limite inferior, se sustituye ese limite. Si la funcion es mayor que 0 en el limite inferior, se sustituye ese limite

3.2. Si el punto medio es menor que 0, se sustituye ese punto con el limite de signo negativo.
Si la funcion es menor que 0 en el limite inferior, se sustituye ese limite. Si la funcion es menor que 0 en el limite inferior, se sustituye ese limite

5. Si el nuevo rango cumple con el criterio de detención, se acaba el algoritmo,              


-----EJEMPLO:
Veamos un ejemplo del método de bisección con una función simple y sin ambigüedades para facilitar el algoritmo.
Tomemos la función f(x) = x - 100.

1. Lo primero que hay que hacer es establecer un rango inicial.
De esta función sabemos que el f(x) = 0 esta en x = 100, entonces nuestro rango inicial deberá estar alrededor de x = 100.
Para hacer mas fácil de visualizar la evolución del algoritmo, usaremos como rango inicial [50, -200].
Con eso tenemos f(x) = x - 100 y [-50, 200].

2. Establecer un criterio de detención.
Digamos que nos vamos a detener cuando el tamaño del rango sea igual o menor a 0.01

3. 



